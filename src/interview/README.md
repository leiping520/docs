---
icon: home
toc: true
sidebar: false
breadcrumb: false # 是否开启路径导航
---

# MYSQL知识点

> [mysql 索引优化](https://tech.meituan.com/2014/06/30/mysql-index.html)

#### 基础部分

1. drop、truncate、 delete区别

   1.DROP TABLE • 作用：这个命令彻底删除整个表，包括表结构、所有数据、索引和权限等。 • 特点：执行速度快，因为不需要逐行删除数据，也无法回滚。 • 使用场景：当你不再需要一个表及其所有相关数据和结构时。

   2.TRUNCATE TABLE • 作用：删除表中的所有数据，保留表结构。 • 特点： • 执行速度快，类似于DROP，因为它重新创建了表并放弃了所有数据，而无需记录每一行的删除操作。 • 自动提交事务，不可回滚。 •
   重置自增列（如果有的话）回到初始值 • 使用场景：当你需要清空表的所有数据，但还想保留表结构时。

   3.DELETE • 作用：删除表中的数据，可以选择性地删除满足特定条件的行。 • 特点： • 可以带条件执行，只删除满足条件的记录。 • 消耗资源较多，特别是数据量大时，因为它需要记录每一条被删除的记录，以便事务可以回滚。 •
   可以回滚，是事务安全的。 • 使用场景：当你需要删除表中一部分数据，并且希望这个操作是可逆的（通过事务回滚）时。


2. 简单总结数据库三范式是什么? 数据库三范式是设计规范，确保数据高效、无冗余： 1.第一范式：确保每列不可分，数据原子性。 2.第二范式：非主键列依赖整个主键。 3.第三范式：非主键列间相互独立，无传递依赖。

3. 解释数据库反范式化

   数据库反范式化是针对数据库规范化的一种设计策略，它通过有意地引入数据冗余、重复的字段或 denormalization 来优化特定的查询性能或简化数据访问

   1.提升查询速度：通过在表中加入冗余数据，可以避免复杂的联接操作，使得查询只需在一个表中完成，从而减少查询时间和提高效率。 2.简化应用程序代码：应用程序可能无需执行多表联查就能获取所需的所有数据，这可以减少代码复杂度并提高开发效率。
   3.减少磁盘I/O操作：通过预先计算并存储汇总数据（如计数、总和等），可以减少运行时的计算负担和磁盘读取次数。

4. union和union all有什么不同?

   UNION 和 UNION ALL 都是用来合并两个或多个SELECT语句的结果集，但它们之间存在一个关键的区别： • 列数和数据类型必须相同：UNION 合并的每个查询，必须返回相同数量的列，且每列的数据类型必须相同或兼容。 •
   UNION: 会去除结果集中的重复行。在返回结果前，它会对所有结果集进行排序并合并，同时消除完全相同的行。 这个过程需要进行排序操作，因此如果数据量大，可能会比较耗时。 • UNION ALL:
   不会去除重复行。它直接将各个SELECT语句的结果合并在一起，不做去重处理。 因此，如果源数据中有重复行，在结果集中也会显示出来。由于省去了去重和排序的过程，UNION ALL通常比UNION效率更高。

   总结来说，如果你需要合并的结果集中不包含重复行，应该使用UNION；如果你不在乎结果集中是否有重复行，并且追求更高的查询效率，应选择UNION ALL。

5. SQL语句执行顺序

   下面是标准的SQL查询（主要是指SELECT语句）执行的大致步骤，需要注意的是，不同的数据库系统可能有细微差异，但基本遵循以下顺序：
    1. FROM: 首先，确定查询涉及的表。如果有多个表通过JOIN连接，这一步也会解析JOIN条件。
    2. ON: 处理JOIN子句中的条件，确定如何连接表。
    3. WHERE: 应用WHERE子句中的条件，过滤不符合条件的行。
    4. GROUP BY: 将结果集按照GROUP BY子句中的列进行分组。
    5. HAVING: 对GROUP BY后的结果应用HAVING子句中的条件，进一步过滤分组。
    6. SELECT: 此时处理SELECT列表，计算所有的列表达式。
    7. DISTINCT: 如果SELECT语句中包含了DISTINCT关键字，这时会去除重复的行。
    8. ORDER BY: 根据ORDER BY子句中的列对结果集进行排序。
    9. LIMIT/TOP: 如果语句中有限制返回行数的子句（如MySQL的LIMIT或SQL Server的TOP），此时会应用这些限制。
    10. OFFSET/FETCH: 在某些数据库中（如SQL Server的OFFSET-FETCH或MySQL的LIMIT OFFSET），还会在此步处理分页查询。
        记住，这个顺序是一个逻辑上的概念，实际的数据库引擎内部可能采用更优化的方式来执行查询，不一定严格按这个顺序进行。但理解这个逻辑有助于我们编写更有效的SQL语句。

6. null的含义

   在SQL中，NULL值表示一个不确定的或者未知的数据。它与空字符串、零或任何其他值都不相同。以下几点详细解释了NULL的含义： • 缺失数据:
   NULL常用来表示数据表中的某个字段没有值或者值未知。这与字段为空字符串或数值0有本质区别，因为空字符串和0都是具体的值，而NULL则表示“没有值”。 • 三值逻辑:
   SQL支持TRUE、FALSE以及UNKNOWN（由NULL代表）的三值逻辑。这意味着在比较操作中，任何涉及NULL的比较（如=, !=, <, >等）都会返回UNKNOWN， 除非使用IS NULL或IS NOT
   NULL来明确测试NULL值。 • 集合运算: 在UNION操作中，NULL值会被视为相等，即使它们来自不同的源。 • 聚合函数: NULL值在计算如COUNT, AVG, SUM等聚合函数时通常会被忽略，但COUNT(*)
   会包括NULL值。 简而言之，NULL是SQL中一种特殊的标记，用来表示未知或不可用的信息，它在处理查询时有着特殊的规则。

7.索引的类型, 建索引的原则

    物理存储角度
    - 聚簇索引
    - 非聚簇索引，也叫辅助索引

    数据结构角度
    - B+数索引
    - Hash索引
    - 全文索引（5.6之前仅在存储引擎为MyISam时可以）
    - R-tree索引

    逻辑角度
    - 主键索引：是一种唯一索引，不允许空值
    - 单列索引：每个索引只能包含单个列，一个表中可以多个单列索引
    - 组合索引：每个索引至少包含2个列字段，查询服从最左分配原则
    - 唯一索引：增加此索引的列在表中的值必须唯一
    - 空间索引：针对空间列字段加的索引

    索引的类型主要有以下几种：

    1. 单一索引(Single Index): 只基于单个列创建的索引。
    2. 复合索引(Composite Index): 基于多列创建的索引。复合索引的列顺序会影响其效率，因为数据库会优先考虑索引的最左前缀原则。
    3. 唯一索引(Unique Index): 确保索引列中的值是唯一的。如果试图插入重复的值，数据库将阻止该操作或返回错误。
    4. 主键索引(PRIMARY KEY Index): 一种特殊的唯一索引，用于标识表中的每一行记录。一张表只能有一个主键索引。
    5. 全文索引(Full-text Index): 用于全文搜索，可以高效地处理LIKE操作符以及复杂的文本搜索请求。
    6. 空间索引(Spatial Index): 用于地理位置和几何数据类型的索引，如点、线、面等。
    7. 位图索引(Bitmap Index): 在数据仓库等场景下使用较多，适用于低基数（值的种类少）的列，能有效压缩存储空间并提高查询速度。

    建索引的原则包括：

    1. 频繁查询的列: 经常出现在WHERE子句中的列应被考虑建立索引。
    2. 区分度高: 列的值分布要尽量广泛，避免大量重复值的列上建索引，因为这样索引的效率会降低。
    3. 索引选择性: 选择性高的索引更有用，即索引列中不同值的数量与表中总行数的比例要高。
    4. 考虑查询代价: 索引可以加速查询，但会占用额外的磁盘空间，且在插入、删除、更新操作时需要维护索引，可能会增加这些操作的成本。
    5. 复合索引策略: 在创建复合索引时，考虑查询中经常一起出现的列，并将最常用作筛选条件的列放在前面。
    6. 避免过度索引: 过多的索引会占用更多的存储空间，影响写操作性能，选择最有效的索引至关重要。
    7. 避免为小表建索引

    总结： 索引类型：常用的包括普通索引、唯一索引、主键索引、组合索引、全文索引等。 
    建索引的原则：选择合适的列、避免频繁更新的列、为唯一性高的列创建索引、组合索引的顺序很重要、避免过多索引、避免为小表创建索引。


8. MySQL InnoDB、Mysaim的特点？


    1. InnoDB 的特点 InnoDB 是 MySQL 的默认存储引擎，提供了许多高级功能，尤其在数据完整性和高并发场景下表现优异。

    主要特点： 
    事务支持：InnoDB 是支持 ACID（原子性、一致性、隔离性、持久性）事务的存储引擎，支持 COMMIT、ROLLBACK 和 SAVEPOINT 操作。
    这意味着它适合那些对数据一致性要求较高的应用，比如金融系统。
    
    行级锁（Row-level Locking）：InnoDB 使用行级锁定，意味着每次修改的只是一行数据，而不是整张表。
    相较于 MyISAM 的表级锁，这显著提升了高并发写入场景的性能。 

    外键支持：InnoDB支持外键约束，允许设置外键以维护表之间的引用完整性，这对于需要保持数据完整性的系统非常有用。 
    
    崩溃恢复能力：InnoDB 采用 Redo Log 和 Undo Log 来确保在崩溃或停电时数据的完整性。通过这些日志，InnoDB能够在数据库崩溃后进行自动恢复。 
    
    聚簇索引（Clustered Index）：InnoDB 使用聚簇索引存储数据。这意味着数据和索引存储在一起，主键索引同时也是数据的物理存储顺序。因此，基于主键的查询效率会更高。
    
    性能优化：InnoDB 具有良好的读写性能，尤其适合高并发的在线事务处理（OLTP）系统。

    适用场景： 需要事务支持的系统，如金融系统、银行系统。 高并发写入操作频繁的场景。 需要维护数据一致性和完整性的系统。 需要使用外键的复杂数据库设计。

    2. MyISAM 的特点 MyISAM 是 InnoDB 之前 MySQL 默认的存储引擎，适用于轻量级的数据库应用，主要特点是简单、快速，但功能不如 InnoDB 完善。

    主要特点： 无事务支持：MyISAM 不支持事务处理。如果应用需要事务支持，比如回滚、提交操作，那么 MyISAM 并不适合。 表级锁（Table-level Locking）：MyISAM 采用表级锁定，这意味着当一条记录被更新时，
    整个表会被锁定，其他的写操作必须等待。虽然对于读取较多、写入较少的场景表现良好，但在高并发写入操作下，MyISAM 的性能会受到限制。

    没有外键支持：MyISAM 不支持外键约束，因此数据表之间的引用完整性必须通过应用程序来维护。 更高的读取性能：由于 MyISAM 的结构相对简单，它的读操作性能往往优于 InnoDB。对于读多写少的应用，它可能更具优势。
    表和索引分开存储：MyISAM 将表和索引分开存储，表以 .MYD 文件格式存储，索引以 .MYI 文件格式存储。这使得它的表格空间管理比 InnoDB 更为简单。 全文索引（Full-text Indexing）：MyISAM
    在早期版本中就支持全文索引（在 InnoDB 5.6 之前，只有 MyISAM 提供全文索引），这使它适合一些需要文本搜索的应用。

    适用场景： 读多写少的系统，比如博客、新闻站点等，尤其是大部分操作是读取而不是更新。 数据一致性要求不高的场景。 不需要事务或外键支持的应用。 对于快速查询和文本搜索有较高要求的应用


9. myisam与innodb的区别


    - InnoDB支持事物，而MyISAM不支持事物
    - InnoDB支持行级锁，而MyISAM支持表级锁
    - InnoDB支持MVCC, 而MyISAM不支持
    - InnoDB支持外键，而MyISAM不支持
    - InnoDB不支持全文索引，而MyISAM支持。

10. Mysql8.0自带哪些存储引擎？分别是做什么的？


1.InnoDB存储引擎

InnoDB是MySQL的默认事务型引擎，它被设计用来 处理大量的短期(short-lived)事务 。可以确保
事务的完整提交(Commit)和回滚(Rollback)。
除非有非常特别的原因需要使用其他的存储引擎，否则 应该优先考虑InnoDB引擎 。
数据文件结构：
表名.frm 存储表结构（MySQL8.0时，合并在表名.ibd中）
表名.ibd 存储数据和索引

InnoDB不仅缓存索引还要缓存真实数据， 对内存要求较 高 ，而且内存大小对性能有决定性的影
响。


2. MyISAM存储引擎

MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但 MyISAM不支持事务和行级
锁 ，有一个毫无疑问的缺陷就是崩溃后无法安全恢复。
优势是访问的 速度快 ，对事务完整性没有要求或者以SELECT、INSERT为主的应用。
数据文件结构：
表名.frm 存储表结构
表名.MYD 存储数据
表名.MYI 存储索引

SHOW VARIABLES LIKE '%default_storage_engine%';
MyISAM只缓存索引，不缓存真实数据。


3. Archive引擎

Archive档案存储引擎只支持INSERT和SELECT操作 。

Archive表适合日志和数据采集（档案）类应用。
根据英文的测试结论来看，Archive表比MyISAM表要小大约75%，比支持事务处理的InnoDB表小
大约83%。

4. Blackhole引擎

Blackhole引擎没有实现任何存储机制，它会丢弃所有插入的数据，不做任何保存 。
但服务器会记录Blackhole表的日志，所以可以用于复制数据到备库，或者简单地记录到日志。但
这种应用方式会碰到很多问题，因此并不推荐。


5. CSV引擎

CSV引擎可以将普通的CSV文件作为MySQL的表来处理，但不支持索引 。

CSV引擎可以作为一种数据交换的机制，非常有用。

CSV存储的数据直接可以在操作系统里，用文本编辑器，或者excel读取。


6. Memory引擎

如果需要快速地访问数据，并且这些数据不会被修改，重启以后丢失也没有关系，那么使用

Memory表是非常有用。

Memory表至少比MyISAM表要快一个数量级。



10. 视图与 临时表的区别

视图和临时表是两种不同的数据库对象，它们在使用场景、创建方式、数据存储和生命周期等方面有显著区别。以下是它们的主要区别：

### 1. 数据存储

- **视图**：
    - 视图是一个虚拟表，不实际存储数据。它依赖于基础表，数据通过查询基础表实时生成。
    - 每次查询视图时，系统都会重新执行视图的定义查询，从基础表中获取数据。

- **临时表**：
    - 临时表是一种实际存在的表，它会在创建时存储数据。
    - 临时表的数据是独立的，临时表一旦创建后，数据可以被多次查询，直到临时表被删除或会话结束。

### 2. 生命周期

- **视图**：
    - 视图是持久的，创建后一直存在，除非被显式删除（`DROP VIEW`）。
    - 视图的生命周期与数据库实例相关，视图可以被多个用户和会话访问。

- **临时表**：
    - 临时表的生命周期与数据库会话或事务相关。它可以是会话级临时表或事务级临时表：
        - 会话级：在会话关闭时自动删除。
        - 事务级：事务结束时自动删除。
    - 临时表在每个会话中是独立的，其他会话看不到该临时表。

### 3. 数据更新

- **视图**：
    - 视图通常是只读的，尤其是当它们涉及多个表或复杂查询（如聚合函数、分组、连接等）。 有些简单视图可以进行 `INSERT`、`UPDATE` 或 `DELETE` 操作，但限制较多，且最终这些操作会作用于基础表。
    - 视图不持有数据的物理副本，因此更新操作是间接地在基础表上进行的。

- **临时表**：
    - 临时表是一个实际的表，可以像普通表一样进行 `INSERT`、`UPDATE` 和 `DELETE` 操作，数据在表中持久化到临时表被删除或会话结束。
    - 可以在临时表中存储中间结果，便于复杂查询中的重复使用。

### 4. 使用场景

- **视图**：
    - 简化复杂查询：将复杂查询封装为视图，便于重用和维护。
    - 提供数据抽象层：隐藏基础表的复杂结构，只展示需要的列或行。
    - 提升数据安全性：限制用户访问基础表的某些敏感数据。

- **临时表**：
    - 存储中间结果：在复杂查询或操作中，临时表可以存储中间结果，避免重复计算。
    - 临时数据操作：当需要在会话或事务内存储和处理临时数据时，可以使用临时表。
    - 加速查询：通过将复杂查询的中间结果存储在临时表中，可以避免在每次查询时重复计算。

### 5. 创建语法

- **视图**：
  ```sql
  CREATE VIEW view_name AS
  SELECT column1, column2
  FROM table_name
  WHERE condition;
  ```

- **临时表**：
  ```sql
  CREATE TEMPORARY TABLE temp_table_name (
      column1 datatype,
      column2 datatype
  );
  ```

### 6. 作用域

- **视图**：
    - 作用于整个数据库，可以被任何有权限的用户访问和使用，视图本身的生命周期不限于当前会话。

- **临时表**：
    - 作用域仅限于当前会话或事务，其他会话无法访问临时表。每个会话的临时表是独立的。

### 总结

| 特性            | 视图                                      | 临时表                                   |
|-----------------|-------------------------------------------|------------------------------------------|
| 数据存储        | 不存储数据，依赖基础表                    | 存储数据，存储实际的查询结果             |
| 生命周期        | 持久存在，直到显式删除                    | 会话或事务结束时自动删除                 |
| 更新数据        | 可能是只读，有时可以更新基础表            | 可以自由更新数据，和普通表一样操作       |
| 使用场景        | 简化复杂查询，数据抽象和安全控制          | 存储临时数据，减少重复计算，提升性能     |
| 作用域          | 数据库级别，多个用户会话共享              | 当前会话或事务级别                      |

总的来说，视图适合用于简化查询和数据抽象，而临时表更适合用于存储临时数据或中间结果。

11. 什么是数据库事务？

是数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作；
这些操作作为一个整体一起向系统提交，要么都执行、要么都不执行；
事务是一组不可再分割的操作集合（工作逻辑单元）

12. 事务的ACID特性是什么？
   原子性,一致性, 隔离性, 持久性
   隔离性：并发事务互相干扰 （一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并
   发执行的各个事务之间不能互相干扰）

   持久性：一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的

13. 并发事务会有哪些问题？

多个事务并发执行一定会产生相互争夺资源的问题

脏读（Dirty read）

是一个事务在处理过程中读取了另外一个事务未提交的数据
当一个事务正在访问数据并且对其进行了修改，但是还没提交事务，这时另外一个事务也访问了这个数
据，然后使用了这个数据，因为这个数据的修改还没提交到数据库，所以另外一个事务读取的数据就是

“脏数据”，这种行为就是“脏读”，依据“脏数据”所做的操作可能是会出现问题的。

修改丢失（Lost of modify）

是指一个事务读取一个数据时，另外一个数据也访问了该数据，那么在第一个事务修改了这个数据之
后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，这种情况就被称为*修改丢
失

不可重复读（Unrepeatableread）

*指在一个事务内多次读取同一数据，在这个事务还没结束时，另外一个事务也访问了这个数据并对这个
数据进行了修改，那么就可能造成第一个事务两次读取的数据不一致，这种情况就被称为*不可重复读。


幻读（Phantom read）

是指同一个事务内多次查询返回的结果集总数不一样（比如增加了或者减少了行记录）。幻读与不可重复读类似，幻读是指一个事务读取了几行数据，这个事务还没结束，接着另外一个事务插
入了一些数据，在随后的查询中，第一个事务读取到的数据就会比原本读取到的多，就好像发生了幻觉
一样，所以称为**幻读**。

14. 不可重复读和幻读有什么区别？

不可重复读 针对的是一份数据的修改
幻读 针对的是行数修改

15. 什么是事务隔离级别？ MySQL InnoDB 存储引擎默认的事务隔离级别是可重复读（REPEATABLE-READ）

事务隔离级别                  脏读    不可重复读(被修改)    幻读（删减）
读未提交（read-uncommitted）  是          是               是
不可重复读（read-committed）  否          是               是
可重复读（repeatable-read）   否          否               是
串行化（serializable）        否          否                否

16. Mysql事务隔离是如何实现的？

隔离的实现主要是读写锁和MVCC

17. 表级锁和行级锁有什么区别？

表级锁：串行化（serializable）时，整表加锁，事务访问表数据时需要申请锁，虽然可分为读锁和写
锁，但毕竟是锁住整张表，会导致并发能力下降，一般是做ddl处理时使用
行级锁：除了串行化（serializable）时 InnoDB使用的都是行级锁，只锁一行数据，其他行数据不影
响，并发能力强。

18. 什么是行级锁？Mysql如何完成的？

行级锁实现比较复杂不是单纯锁住一行数据，是由mvcc完成的。

19. 什么是共享锁（读锁）？

共享锁或S锁，其它事务可以继续加共享锁，但不能加排它锁

20. 什么是排它锁（写锁/独占锁）？

排它锁或X锁，在进行写操作之前要申请并获得，其它事务不能再获得任何锁。

21. mysql 读锁和写锁的实现

在 MySQL 中，读锁和写锁是为了确保数据一致性和并发性而实现的。以下是对这两种锁的实现和工作原理的详细说明：

### 1. **读锁（Shared Lock）**

- **概念**：读锁允许多个事务并发读取同一数据行，但不允许其他事务对其进行写操作。多个事务可以同时持有读锁，但一旦有事务持有读锁，其他事务不能获得写锁。

- **实现**：
    - **加锁机制**：当一个事务请求对某个行加读锁时，MySQL 会检查当前是否有写锁。如果没有写锁存在，事务就可以成功获得读锁。
    - **行级锁**：在 InnoDB 存储引擎中，读锁是行级锁。它仅锁定当前查询涉及的行，而不是整个表。这种方式允许更高的并发性。

- **使用**：
    - 使用 `SELECT ... LOCK IN SHARE MODE` 或 `SELECT ... FOR UPDATE` 来显式地请求读锁。

### 2. **写锁（Exclusive Lock）**

- **概念**：写锁不允许其他事务对同一数据行进行读或写操作。只有获得写锁的事务可以修改数据行。一旦事务获得写锁，其他事务将无法获取任何类型的锁，直到写锁被释放。

- **实现**：
    - **加锁机制**：当一个事务请求对某个行加写锁时，MySQL 会检查当前是否有读锁或写锁。如果有任何其他事务持有锁，该事务会被阻塞，直到所有锁被释放。
    - **行级锁**：同样，在 InnoDB 存储引擎中，写锁也是行级锁，只锁定当前正在修改的行，保持了较高的并发性。

- **使用**：
    - 使用 `SELECT ... FOR UPDATE` 来显式请求写锁。此语句会在选择行时同时加上写锁。

### 3. **锁的粒度**

- **表级锁 vs 行级锁**：虽然上面提到的锁是行级锁，MySQL 也支持表级锁，但表级锁的并发性能较差。表级锁会锁定整个表，因此在高并发情况下，性能会受到影响。

### 4. **锁的行为**

- **死锁**：在多个事务同时请求锁的情况下，可能会导致死锁。在这种情况下，MySQL 会自动检测死锁并回滚其中一个事务以释放锁。

- **锁等待**：当事务请求的锁被其他事务占用时，该事务会进入等待状态，直到锁被释放。

### 5. **使用场景**

- **读锁的使用场景**：
    - 在数据读取的操作中，可以使用读锁来确保读取的数据在其他事务进行写操作时不会变化。

- **写锁的使用场景**：
    - 在数据更新或删除时，需要使用写锁，以确保对数据的修改是安全的，不会被其他并发事务影响。

### 6. **示例**

- **读锁示例**：
  ```sql
  START TRANSACTION;
  SELECT * FROM your_table WHERE id = 1 LOCK IN SHARE MODE;
  -- 进行读取操作
  COMMIT;
  ```

- **写锁示例**：
  ```sql
  START TRANSACTION;
  SELECT * FROM your_table WHERE id = 1 FOR UPDATE;
  -- 进行写入操作
  UPDATE your_table SET column = value WHERE id = 1;
  COMMIT;
  ```

22. Mysql会产生几种日志


错误日志（error log）

error log主要记录MySQL在启动、关闭或者运行过程中的错误信息，在MySQL的配置文件my.cnf中，
可以通过log-error=/var/log/mysqld.log 执行mysql错误日志的位置。

慢查询日志（slow query log）

MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语
句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。
long_query_time的默认值为10，意思是运行10秒以上的语句。
由他来查看哪些SQL超出了我们的最大忍耐时间值，比如一条sql执行超过5秒钟，我们就算慢SQL，
希望能收集超过5秒的sql，结合之前explain进行全面分析。


默认情况下，MySQL数据库没有开启慢查询日志，需要我们手动来设置这个参数。

当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的
性能影响。慢查询日志支持将日志记录写入文件。

在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具

mysqldumpslow。

一般查询日志（general log）

general log 记录了客户端连接信息以及执行的SQL语句信息，通过MySQL的命令

重写日志（redo log）
回滚日志（undo log）
二进制日志（bin log


### 总结

MySQL 的读锁和写锁通过行级锁的方式来控制并发事务的安全性。读锁允许多个事务同时读取，而写锁则确保数据的独占修改。通过合理使用这些锁，可以有效管理数据的并发访问和一致性。

#### 实战部分

1. 列举几种表连接方式,有什么区别？

    1. 内连接 (INNER JOIN): 内连接返回两个表中满足连接条件的所有记录。只有当连接键在两个表中都存在时，才会显示对应的结果行。
    2. 左连接 (LEFT JOIN / LEFT OUTER JOIN): 左连接以左表为基础，返回左表中的所有记录，即使右表中没有匹配的记录。如果右表中没有匹配项，则结果集中右表的部分将包含NULL值。
    3. 右连接 (RIGHT JOIN / RIGHT OUTER JOIN): 右连接与左连接相反，它以右表为基础，返回右表中的所有记录，左表中没有匹配的记录将以NULL值填充。
    4. 全外连接 (FULL OUTER JOIN): 全外连接返回左表和右表中的所有记录。如果某一边没有匹配项，则另一边相应的列值为NULL。
    5. 交叉连接 (CROSS JOIN): 交叉连接，也称为笛卡尔积，返回左表的每一行与右表的每一行的组合。如果没有指定ON条件，那么结果集的大小将是两个表行数的乘积。 区别:
       •数据覆盖范围: 内连接只显示匹配的记录，而左连接、右连接分别确保左表或右表的记录不丢失，全外连接则展示两边的所有记录，即使某些记录在另一侧没有匹配。 •NULL处理:
       左连接和右连接会在缺少匹配时用NULL填充，全外连接可能在任一表缺少匹配时填充NULL。 •记录数量: 交叉连接会产生非常大的结果集，特别是当两个表都很庞大时。
       这些连接类型的选择取决于你希望如何合并表中的数据以及你需要展现的信息详细程度

2. mysql不支持full join？

   是的，MySQL传统上并不直接支持FULL OUTER JOIN。 FULL OUTER JOIN会返回左表和右表中的所有行，匹配的行彼此相邻，而未匹配的行会在对应的另一侧填充NULL值。 尽管MySQL没有内置的FULL OUTER
   JOIN语法，但你可以通过使用UNION或者子查询来模拟这一行为，以联合LEFT JOIN和RIGHT JOIN的结果来达到相同的目的。

   例如，要实现类似FULL OUTER JOIN的效果，可以这样做：

   (SELECT a.*, b.* FROM table_a AS a LEFT JOIN table_b AS b ON a.id = b.id)
   UNION
   (SELECT a.*, b.* FROM table_a AS a RIGHT JOIN table_b AS b ON a.id = b.id)

    1. 主键和外键的区别？

       1.主键 (Primary Key):
       • 唯一性: 主键是用来唯一标识表中每一行记录的字段，确保不会有两行记录有相同的主键值。 • 非空性: 主键列不允许有NULL值。 • 索引: 通常情况下，主键自动创建唯一索引，这有助于快速查找和排序数据。 • 表约束:
       每个表只能有一个主键，但主键可以由一个或多个列组成（复合主键）。

       2.外键 (Foreign Key):
       • 引用完整性: 外键用于建立两个表之间的关联关系，它引用另一个表的主键。外键所在的表称为从表或子表，被引用的表称为父表或主表。 • 可为空性: 外键列可以包含NULL值，这意味着子表中的记录不必都与父表中的记录相对应。 •
       维护引用关系: 外键约束可以帮助维护数据库的引用完整性，确保不能在子表中插入不存在于父表中的外键值，同时，在删除或更新父表中的记录时， 可以配置级联操作来同步更新或删除子表中的相关记录。 • 多对一或多对多关系:
       外键是实现数据库中多对一或一对多关系的关键，通过它可以实现实体之间的关联查询。

       如何创建呢？ CREATE TABLE employees (
       employee_id INT NOT NULL, first_name VARCHAR(50), last_name VARCHAR(50), -- 其他列... PRIMARY KEY (employee_id)
       );

       CREATE TABLE employees (
       employee_id INT PRIMARY KEY, first_name VARCHAR(50), last_name VARCHAR(50), department_id INT, -- 其他列... FOREIGN
       KEY (department_id) REFERENCES departments(department_id)
       );

3. order by与group by的区别


    1.ORDER BY:
    目的: 用于对查询结果进行排序，可以按照一个或多个列进行升序(ASC)或降序(DESC)排列。 
    位置: 通常放在 SQL 语句的末尾，但在使用聚合函数和 GROUP BY 时，可能位于 GROUP BY 之后。 
    应用场景: 当你需要按照特定列的值对结果集进行排序，以便于查看或分析数据时使用。

    2.GROUP BY:
    目的: 用于将查询结果集按照一个或多个列进行分组，每个组中包含具有相同列值的行。常与聚合函数如 SUM, AVG, COUNT, MAX, MIN 等一起使用，以计算每个组的汇总信息。 
    位置: 放在 WHERE子句之后，HAVING 子句之前（如果有的话）。 
    应用场景: 当需要对数据进行分类汇总统计时使用，例如计算每个部门的平均工资、每个类别的总销售额等。

    总结来说，ORDER BY 关注的是查询结果的排序，而 GROUP BY 则关注于将数据分组并进行聚合计算。 两者可以结合使用，但要注意 GROUP BY 必须在 ORDER BY 之前（如果同时使用的话）


4. 某个表有数千万数据，查询比较慢，如何优化？说一下思路

在面对数千万条数据的表时，优化查询性能是一个重要的任务。以下是一些优化查询的思路和方法：

### 1. **索引优化**

- **创建适当的索引**：确保常用查询的字段上有索引，特别是用于过滤（`WHERE`）、排序（`ORDER BY`）和连接（`JOIN`）的字段。
- **复合索引**：考虑创建复合索引，涵盖多个列的查询条件，以减少查询时的扫描量。
- **避免过度索引**：虽然索引可以加快查询，但过多的索引会影响写入性能并占用存储空间，因此需要找到一个平衡点。

### 2. **查询优化**

- **使用合适的查询方式**：尽量使用 `SELECT` 只获取需要的列，避免使用 `SELECT *`。
- **减少子查询**：考虑使用连接（`JOIN`）替代子查询，避免不必要的嵌套查询。
- **过滤数据**：尽量在查询中使用 `WHERE` 条件过滤数据，减少结果集大小。
- **分页查询**：对于大数据集的查询，使用分页（如 `LIMIT` 和 `OFFSET`）来分批处理数据。

### 4. **数据库配置**

- **调整数据库参数**：根据应用需求和服务器配置，优化数据库的参数，如缓冲区大小、缓存设置等，以提升性能。
- **使用连接池**：在应用层面使用数据库连接池，减少频繁创建和关闭数据库连接的开销。

### 5. **查询分析**

- **使用 `EXPLAIN`**：利用 `EXPLAIN` 语句分析查询的执行计划，找出性能瓶颈。
- **分析慢查询**：启用慢查询日志，记录执行时间超过特定阈值的查询，针对这些查询进行优化。

### 6. **分区表**

- **表分区**：对于非常大的表，可以考虑使用分区（Partitioning）来将表分为更小的、独立的部分，这样可以加速某些查询。

### 7. **缓存机制**

- **应用层缓存**：使用缓存机制（如 Redis、Memcached）缓存常用查询结果，减少对数据库的直接查询。
- **数据库缓存**：确保数据库本身的查询缓存功能开启，并适当配置。

### 8. **硬件优化**

- **升级硬件**：如果上述优化措施仍未能满足性能需求，考虑增加硬件资源，如增加内存、使用更快的硬盘（如 SSD）等。

### 总结

优化数据库查询性能通常需要综合考虑多种因素，进行逐步分析和调整。通过索引优化、查询优化、表结构优化、数据库配置、使用缓存和硬件升级等手段，能够有效提高查询性能。
重要的是定期分析查询性能和执行计划，以便不断优化。


5. count(列名)和 count(*)有什么区别？

count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。

6. 如何优化过多join查询关联？

适当使用冗余字段减少多表关联查询
驱动表和被驱动表（小表join大表）
业务允许的话 尽量使用inner join 让系统帮忙自动选择驱动表
关联字段一定创建索引
调整JOIN BUFFER大小



#### MySQL分库分表

1. 什么情况下需要分库？什么情况下需要分表？

   当数据库的QPS过高，数据库连接数不足的时候，就需要分库。
   当单表数据量过大，读写性能较差，就需要分表。
   当两者都有的时候，就需要分库分表。

   至于先分库还是先分表？建议先分表，如果分表能解决问题，就不需要分库了，毕竟需要单独服务器资源，成本更高

2. 如何实现分库分表？有哪些拆分方式？

分库分表有垂直拆分和水平拆分。垂直拆分又有垂直分库、垂直分表。

垂直分库，不同的业务拆分到不同的数据库。

垂直分表，把长度较大或者访问频次较低的字段，拆分到扩展表中。

水平分表，单表数据量过大时，按照订单ID拆分到多张表中。

3. 分库分表引入哪些问题？

垂直分库： 不同库多表之间无法join关联查询，只能通过接口聚合，复杂度直线上升。
          横跨多个数据库导致无法使用本地事务，数据强一致性就别想了，只能引入更为复杂的分布式事务，勉强实现数据的最终一致性，可用性直线下降。

垂直分表： 本来一张表能查出来的数据，现在需要多张表join关联查询，这不瞎耽误事。

水平分表： 多张表关联查询时，无法实现分页、排序功能。

4. 分库分表引入问题的解决方案？


跨库查询问题： 采用字段冗余方案，比如订单表存储店铺ID、店铺名称，就不需要再查询商户数据库了。 不过这种方案要求冗余字段要很少变动，就算变动后，也能容忍返回旧数据。
多表分页查询问题： 这个处理起来就很需要技术含量了。 
                比如：订单表按照订单ID分片，(order_id % 128)，分成了128张表。 Leader看了说：每张表的数据量差不多，分的很均匀，以后不要再分了。 
                同一个用户的订单散落在不同的表，用户想查询自己的订单，根本无法做到分页查询。难道一次全部查询该用户的所有订单，然后做内存分页，多大的机器内存都让你搞挂。
                想要实现用户订单分页查询，可以采用按照用户ID分片，(user_id % 128)，这样同一个用户的订单只会存储在一张表中，咋分页展示都行。
                没有完美的分片方案，如果商户想要分页查看自己店铺的订单怎么办？
                那就把订单再冗余存储一份，按照店铺ID分片，(shop_id % 128)。不过由于商户数量较少，可以搞个异步线程往商户订单分片表同步。
                订单按照用户ID分片后，发生数据倾斜怎么办？
                因为不同用户的订单量是不同的，一个爱好购物的小姐姐的订单量抵得上几十个老爷们。导致一张表数据几百条，另一张表数据量千万级，这该咋整？
                做冷热数据分离，基础库只存储3个月内的订单，其他的移动到历史订单库。这个要跟产品商量好，3个月前的订单需要单独的查询页面。
