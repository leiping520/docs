import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as e,c as l,e as s}from"./app-SMzT8O0c.js";const n="/docs/assets/images/image25.png",o="/docs/assets/images/image26.png",a="/docs/assets/images/image24.png",t="/docs/assets/images/image27.png",c="/docs/assets/images/image28.png",d={},r=s('<h1 id="分布式系统" tabindex="-1"><a class="header-anchor" href="#分布式系统"><span>分布式系统</span></a></h1><h2 id="_1-分布式缓存及方案实现" tabindex="-1"><a class="header-anchor" href="#_1-分布式缓存及方案实现"><span>1.分布式缓存及方案实现</span></a></h2><div class="hint-container tip"><p class="hint-container-title">提示</p><p>像MySql等传统的关系型数据库已经不能适用于所有的业务场景，比如电商系统的秒杀场景，APP首页的访问流量高峰场景，很容易造成关系型数据库的瘫痪，随着缓存技术的出现很好的解决了这个问题。</p></div><h3 id="缓存的概念-什么是缓存" tabindex="-1"><a class="header-anchor" href="#缓存的概念-什么是缓存"><span>缓存的概念（什么是缓存）</span></a></h3><p>缓存就是把访问量较高的热点数据从传统的关系型数据库中加载到内存中，当用户再次访问热点数据时是从内存中加载，减少了对数据库的访问量，解决了高并发场景下容易造成数据库宕机的问题。</p><h3 id="为什么要用缓存-为什么要用redis作为缓存" tabindex="-1"><a class="header-anchor" href="#为什么要用缓存-为什么要用redis作为缓存"><span>为什么要用缓存（为什么要用redis作为缓存）</span></a></h3><p>针对于这个问题要从两个方面去考虑，一个是应用系统的高并发场景，另一个就是应用系统的高性能情况。</p><ul><li><p>高性能情况：</p><ul><li>用户第一次访问数据时，缓存中没有数据，要从数据库中获取数据，因为是从磁盘中拿数据，读取数据的过程比较慢。拿到数据后将数据存储在缓存中，用户第二次访问数据时，可以从缓存中直接获取，因为缓存是直接操作内存的，访问数据速度比较快。</li></ul><figure><img src="'+n+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></li><li><p>高并发场景下：</p><ul><li>操作缓存能够承受的并发访问量是远远大于访问数据库的，比如redis，它的读的速度是110000次/s，写的速度是81000次/s。所以说将数据库中访问量高的数据存储到缓存中，用户请求的时候直接访问数据库，不必访问数据库，提高应用程序的并发量。</li></ul><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></li></ul><h3 id="缓存的分类有哪些" tabindex="-1"><a class="header-anchor" href="#缓存的分类有哪些"><span>缓存的分类有哪些</span></a></h3><p>缓存基本上分为三类：<code>本地缓存</code>、<code>分布式缓存</code>、<code>多级缓存</code>。根据缓存和应用程序是否属于同一个进程，将缓存分为本地缓存和分布式缓存。 基于本地缓存和分布式缓存都有各自的优点和缺点，后面又出现了多级缓存的概念</p><h4 id="本地缓存" tabindex="-1"><a class="header-anchor" href="#本地缓存"><span><strong>本地缓存</strong></span></a></h4><ul><li>本地缓存的概念： <ul><li>本地缓存是指和应用程序在同一个进程内的内存空间去存储数据，数据的读写都是在同一个进程内完成的</li></ul></li><li>本地缓存优点： <ul><li>读取速度快，但是不能进行大数据量存储。</li><li>本地缓存不需要远程网络请求去操作内存空间，没有额外的性能消耗，所以读取速度快。但是由于本地缓存占用了应用进程的内存空间，比如java进程的jvm内存空间，故不能进行大数据量存储。</li></ul></li><li>本地缓存缺点： <ul><li>应用程序集群部署时，会存在数据更新问题（数据更新不一致） 本地缓存一般只能被同一个应用进程的程序访问，不能被其他应用程序进程访问。 在单体应用集群部署时，如果数据库有数据需要更新，就要同步更新不同服务器节点上的本地缓存的数据来保证数据的一致性，但是这种操作的复杂度高，容易出错。 可以基于redis的发布/订阅机制来实现各个部署节点的数据同步更新。</li><li>数据会随着应用程序的重启而丢失 因为本地缓存的数据是存储在应用进程的内存空间的，所以当应用进程重启时，本地缓存的数据会丢失。</li></ul></li><li>本地缓存的实现： <ul><li>缓存存储的数据一般都是key-value键值对的数据结构，在java语言中，常用的字典实现包括 HashMap 和 ConcurretHashMap。</li><li>除了上面说的实现方式以外，也可以用Guava、Ehcache以及Caffeine等封装好的工具包来实现本地缓存。</li></ul></li></ul><h4 id="分布式缓存" tabindex="-1"><a class="header-anchor" href="#分布式缓存"><span><strong>分布式缓存</strong></span></a></h4><ul><li>分布式缓存概念： <ul><li>分布式缓存是独立部署的服务进程，并且和应用程序没有部署在同一台服务器上。所以是需要通过远程网络请求来完成分布式缓存的读写操作，并且分布式缓存主要应用在应用程序集群部署的环境下。</li></ul></li><li>分布式缓存优点： <ul><li>支持大数据量存储 <ul><li>分布式缓存是独立部署的进程，拥有自身独自的内存空间，不需要占用应用程序进程的内存空间，并且还支持横向扩展的集群方式部署，所以可以进行大数据量存储。</li></ul></li><li>数据不会随着应用程序重启而丢失 <ul><li>分布式缓存和本地缓存不同，拥有自身独立的内存空间，不会受到应用程序进程重启的影响，在应用程序重启时，分布式缓存的存储数据仍然存在。</li></ul></li><li>数据集中存储，保证数据的一致性 <ul><li>当应用程序采用集群方式部署时，集群的每个部署节点都有一个统一的分布式缓存进行数据的读写操作，所以不会存在像本地缓存中数据更新问题，保证了不同服务器节点的 数据一致性。</li></ul></li><li>数据读写分离，高性能，高可用 <ul><li>分布式缓存一般支持数据副本机制，实现读写分离，可以解决高并发场景中的数据读写性能问题。而且在多个缓存节点冗余存储数据，提高了缓存数据的可用性，避免某个缓存节点宕机导致数据不可用问题。</li></ul></li></ul></li><li>分布式缓存缺点： <ul><li>数据跨网络传输，读写性能不如本地缓存</li></ul></li><li>分布式缓存的实现： <ul><li>分布式缓存的典型实现包括 MemCached 和 Redis。</li></ul></li></ul><h4 id="多级缓存" tabindex="-1"><a class="header-anchor" href="#多级缓存"><span><strong>多级缓存</strong></span></a></h4><p>基于本地缓存和分布式缓存的优缺点，多级缓存应运而生，在实际的业务开发中一般也是采用多级缓存。</p><div class="hint-container tip"><p class="hint-container-title">注意</p><p>注意：本地缓存一般存储更新频率低，访问频率高数据，分布式缓存一般存储更新频率很高的数据。</p></div><ul><li>多级缓存的请求流程： <ul><li>本地缓存作为一级缓存，分布式缓存作为二级缓存；当用户获取数据时，先从一级缓存中获取数据，如果一级缓存有数据则返回数据，否则从二级缓存中获取数据。</li><li>如果二级缓存中有数据则更新一级缓存，然后将数据返回客户端。</li><li>如果二级缓存没有数据则去数据库查询数据，然后更新二级缓存，接着再更新一级缓存，最后将数据返回给客户端</li></ul></li></ul><figure><img src="'+a+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>多级缓存的实现： <ul><li>可以使用Guava或者Caffeine作为一级缓存，Redis作为二级缓存。</li></ul></li></ul><div class="hint-container note"><p class="hint-container-title">注意</p><p>在应用程序集群部署时，如果数据库的数据有更新的情况，一级缓存的数据更新容易出现数据不一致的情况。 因为是集群部署，多个部署节点实现一级缓存数据更新难度比较大，不过我们可以通过Redis的消息发布/订阅机制来实现多个节点缓存数据一致性问题。</p></div><h2 id="_2-分布式会话及实现方案" tabindex="-1"><a class="header-anchor" href="#_2-分布式会话及实现方案"><span>2.分布式会话及实现方案</span></a></h2><div class="hint-container tip"><p class="hint-container-title">提示</p><p>无状态的token或者有状态的Session集中管理是目前最为常用的方案，本节主要讨论的有状态的分布式<code>Session会话</code>, 包括<code>Session Stick</code>, <code>Session Replication</code>, <code>Session 数据集中存储</code>, <code>Cookie Based</code> 以及<code>Token</code>方式等</p></div><h3 id="基础概念" tabindex="-1"><a class="header-anchor" href="#基础概念"><span>基础概念</span></a></h3><h4 id="为什么要产生session" tabindex="-1"><a class="header-anchor" href="#为什么要产生session"><span><strong>为什么要产生Session</strong></span></a></h4><ul><li><p>http协议本身是无状态的，客户端只需要向服务器请求下载内容，客户端和服务器都不记录彼此的历史信息，每一次请求都是独立的。</p></li><li><p>为什么是无状态的呢？因为浏览器与服务器是使用socke套接字进行通信，服务器将请求结果返回给浏览器之后，会关闭当前的socket链接，而且服务器也会在处理页面完毕之后销毁页面对象。</p></li><li><p>然而在Web应用的很多场景下需要维护用户状态才能正常工作(是否登录等)，或者说提供便捷(记住密码，浏览历史等)，状态的保持就是一个很重要的功能。因此在web应用开发里就出现了保持http链接状态的技术：一个是cookie技术，另一种是session技术。</p></li></ul><h4 id="session有什么作用-如何产生并发挥作用" tabindex="-1"><a class="header-anchor" href="#session有什么作用-如何产生并发挥作用"><span><strong>Session有什么作用，如何产生并发挥作用</strong></span></a></h4><p>要明白Session就必须要弄明白什么是Cookie，以及Cookie和Session的关系。</p><ul><li><p><strong>Cookie的产生</strong></p><p>当用户首次使用浏览器访问一个支持Cookie的网站的时候，用户会提供包括用户名在内的个人信息并且提交至服务器； 接着，服务器在向客户端回传相应的超文本的同时也会发回这些个人信息，当然这些信息并不是存放在HTTP响应体（Response Body）中的，而是存放于HTTP响应头（Response Header）； 当客户端浏览器接收到来自服务器的响应之后，浏览器会将这些信息存放在一个统一的位置。</p><p>存储在硬盘上的cookie 不可以在不同的浏览器间共享，可以在同一浏览器的不同进程间共享，比如两个IE窗口。这是因为每中浏览器存储cookie的位置不一样，比如:</p><ul><li>Chrome下的cookie放在：C:\\Users\\sharexie\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Cache</li><li>Firefox下的cookie放在：C:\\Users\\sharexie\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles\\tq2hit6m.default\\cookies.sqlite （倒数第二个文件名是随机的文件名字）</li><li>Ie下的cookie放在：C:\\Users\\Administrator\\AppData\\Roaming\\Microsoft\\Windows\\Cookies</li></ul></li><li><p><strong>Cookie的内容、作用域以及有效期</strong></p><ul><li><code>cookie</code>的内容主要包括：名字，值，过期时间，路径和域。路径与域合在一起就构成了<code>cookie</code>的作用范围。</li><li>如果不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，只要关闭浏览器窗口，cookie就消失了，这种生命期为浏览器会话期的 cookie被称为会话cookie。会话cookie一般不存储在硬盘上而是保存在内存里。如果设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。</li></ul></li><li><p><strong>Cookie如何使用</strong></p><ul><li><code>cookie</code> 的使用是由浏览器按照一定的原则在后台自动发送给服务器的。当客户端二次向服务器发送请求的时候，浏览器检查所有存储的cookie，如果某个cookie所声明的作用范围大于等于将要请求的资源所在的位置，则把该cookie附在请求资源的HTTP请求头上发送给服务器。</li><li>有了Cookie这样的技术实现，服务器在接收到来自客户端浏览器的请求之后，就能够通过分析存放于请求头的Cookie得到客户端特有的信息，从而动态生成与该客户端相对应的内容。</li><li>通常，我们可以从很多网站的登录界面中看到“请记住我”这样的选项，如果你勾选了它之后再登录，那么在下一次访问该网站的时候就不需要进行重复而繁琐的登录动作了，而这个功能就是通过Cookie实现的。</li></ul></li><li><p><strong>什么是Session</strong></p><ul><li>Session一般叫做会话，Session技术是http状态保持在服务端的解决方案，它是通过服务器来保持状态的。</li><li>我们可以把客户端浏览器与服务器之间一系列交互的动作称为一个 Session。是服务器端为客户端所开辟的存储空间，在其中保存的信息就是用于保持状态。</li><li>因此，session是解决http协议无状态问题的服务端解决方案，它能让客户端和服务端一系列交互动作变成一个完整的事务。</li></ul></li><li><p><strong>Session的创建</strong></p><ul><li>那么Session在何时创建呢？当然还是在服务器端程序运行的过程中创建的，不同语言实现的应用程序有不同创建Session的方法。</li><li>当客户端第一次请求服务端，当server端程序调用 HttpServletRequest.getSession(true)这样的语句时的时候，服务器会为客户端创建一个session，并将通过特殊算法算出一个session的ID，用来标识该session对象。</li><li>Session存储在服务器的内存中(tomcat服务器通过StandardManager类将session存储在内存中)，也可以持久化到file，数据库，memcache，redis等。</li><li>客户端只保存sessionid到cookie中，而不会保存session。浏览器的关闭并不会导致Session的删除，只有当超时、程序调用HttpSession.invalidate()以及服务端程序关闭才会删除。</li></ul></li><li><p><strong>Cookie与Session的关系</strong></p><ul><li><code>cookie</code>和<code>session</code>的方案虽然分别属于客户端和服务端，但是服务端的session的实现对客户端的cookie有依赖关系的，服务端执行session机制时候会生成session的id值，这个id值会发送给客户端，客户端每次请求都会把这个id值放到http请求的头部发送给服务端，而这个id值在客户端会保存下来，保存的容器就是cookie，因此当我们完全禁掉浏览器的cookie的时候，服务端的session也会不能正常使用。</li></ul></li></ul><h3 id="会话技术的发展" tabindex="-1"><a class="header-anchor" href="#会话技术的发展"><span>会话技术的发展</span></a></h3><ul><li>单机 <ul><li>Session + Cookie</li></ul></li><li>多机器 <ul><li>在负载均衡侧 - Session 粘滞</li><li>Session数据同步</li></ul></li><li>多机器，集群 <ul><li>session集中管理，比如redis；目前方案上用的最多的是SpringSession，早前也有用tomcat集成方式的。</li></ul></li><li>无状态token <ul><li>JWT</li></ul></li></ul><h3 id="分布式会话方案" tabindex="-1"><a class="header-anchor" href="#分布式会话方案"><span>分布式会话方案</span></a></h3><div class="hint-container tip"><p class="hint-container-title">提示</p><p>无状态的token或者有状态的Session集中管理是目前最为常用的方案，本节主要讨论的有状态的分布式Session会话</p></div><h4 id="session-stick" tabindex="-1"><a class="header-anchor" href="#session-stick"><span><strong>Session Stick</strong></span></a></h4><h4 id="session-replication" tabindex="-1"><a class="header-anchor" href="#session-replication"><span><strong>Session Replication</strong></span></a></h4><h4 id="session-数据集中存储" tabindex="-1"><a class="header-anchor" href="#session-数据集中存储"><span><strong>Session 数据集中存储</strong></span></a></h4><h4 id="cookie-based" tabindex="-1"><a class="header-anchor" href="#cookie-based"><span><strong>Cookie Based</strong></span></a></h4><h3 id="token" tabindex="-1"><a class="header-anchor" href="#token"><span><strong>Token</strong></span></a></h3><p>JSON Web Token，一般用它来替换掉Session实现数据共享。</p><ul><li><p>使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的：</p><ul><li>1、客户端通过用户名和密码登录服务器；</li><li>2、服务端对客户端身份进行验证；</li><li>3、服务端对该用户生成Token，返回给客户端；</li><li>4、客户端将Token保存到本地浏览器，一般保存到cookie中；</li><li>5、客户端发起请求，需要携带该Token；</li><li>6、服务端收到请求后，首先验证Token，之后返回数据。</li></ul></li><li><p>优点：</p><ul><li>无状态、可扩展 ：在客户端存储的Token是无状态的，并且能够被扩展。基于这种无状态和不存储Session信息，负载均衡器能够将用户信息从一个服务传到其他服务器上。</li><li>安全：请求中发送token而不再是发送cookie能够防止CSRF(跨站请求伪造)。</li><li>可提供接口给第三方服务：使用token时，可以提供可选的权限给第三方应用程序。</li><li>多平台跨域</li></ul></li></ul><p>对应用程序和服务进行扩展的时候，需要介入各种各种的设备和应用程序。 假如我们的后端api服务器a.com只提供数据，而静态资源则存放在cdn 服务器b.com上。当我们从a.com请求b.com下面的资源时，由于触发浏览器的同源策略限制而被阻止。</p><p>我们通过<code>CORS（跨域资源共享）标准</code>和<code>token</code>来解决资源共享和安全问题。</p><p>举个例子，我们可以设置b.com的响应首部字段为：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>// 第一行指定了允许访问该资源的外域 URI。
Access-Control-Allow-Origin: http://a.com

// 第二行指明了实际请求中允许携带的首部字段，这里加入了Authorization，用来存放token。
Access-Control-Allow-Headers: Authorization, X-Requested-With, Content-Type, Accept

// 第三行用于预检请求的响应。其指明了实际请求所允许使用的 HTTP 方法。
Access-Control-Allow-Methods: GET, POST, PUT,DELETE

// 然后用户从a.com携带有一个通过了验证的token访问B域名，数据和资源就能够在任何域上被请求到。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_3-分布式事务解决方案" tabindex="-1"><a class="header-anchor" href="#_3-分布式事务解决方案"><span>3.分布式事务解决方案</span></a></h2><div class="hint-container tip"><p class="hint-container-title">提示</p><p><code>事务</code>是一个程序执行单元，里面的所有操作要么全部执行成功，要么全部执行失败。而分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。</p></div><h3 id="什么是分布式事务" tabindex="-1"><a class="header-anchor" href="#什么是分布式事务"><span>什么是分布式事务</span></a></h3><p>一个大的操作由N多的小的操作共同完成。而这些小的操作又分布在不同的服务上。针对于这些操作，<strong>「要么全部成功执行，要么全部不执行」</strong>。</p><h3 id="为什么会有分布式事务" tabindex="-1"><a class="header-anchor" href="#为什么会有分布式事务"><span>为什么会有分布式事务</span></a></h3><ul><li>举个例子：</li></ul><figure><img src="`+t+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>转账是最经典的分布式事务场景，假设用户 A 使用银行 app 发起一笔跨行转账给用户 B，银行系统首先扣掉用户 A 的钱，然后增加用户 B 账户中的余额。</p><ul><li>用户 A 的账户扣款成功，用户 B 账户余额增加失败</li><li>用户 A 账户扣款失败，用户 B 账户余额增加成功。</li></ul><p>在 <code>「单体应用」</code>中，我们只需要贴上<code>[ @Transactional ]</code>注解就可以开启事务来保证整个操作的<code>「原子性」</code>。</p><p>但是看似以上简单的操作，在实际的应用架构中，不可能是单体的服务，我们会把这一系列操作交给<code>「N个服务」</code> 去完成，也就是拆分成为<code>「分布式微服务架构」</code>。</p><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>比如下订单服务，扣库存服务等等，必须要<code>「保证不同服务状态结果的一致性」 </code>，于是就出现了分布式事务。</p><h3 id="解决方案" tabindex="-1"><a class="header-anchor" href="#解决方案"><span>解决方案</span></a></h3>',58),p=[r];function h(u,g){return e(),l("div",null,p)}const v=i(d,[["render",h],["__file","index.html.vue"]]),f=JSON.parse('{"path":"/interview/distributed/","title":"分布式系统","lang":"en-US","frontmatter":{"icon":"home","toc":true,"sidebar":false,"breadcrumb":false},"headers":[{"level":2,"title":"1.分布式缓存及方案实现","slug":"_1-分布式缓存及方案实现","link":"#_1-分布式缓存及方案实现","children":[{"level":3,"title":"缓存的概念（什么是缓存）","slug":"缓存的概念-什么是缓存","link":"#缓存的概念-什么是缓存","children":[]},{"level":3,"title":"为什么要用缓存（为什么要用redis作为缓存）","slug":"为什么要用缓存-为什么要用redis作为缓存","link":"#为什么要用缓存-为什么要用redis作为缓存","children":[]},{"level":3,"title":"缓存的分类有哪些","slug":"缓存的分类有哪些","link":"#缓存的分类有哪些","children":[]}]},{"level":2,"title":"2.分布式会话及实现方案","slug":"_2-分布式会话及实现方案","link":"#_2-分布式会话及实现方案","children":[{"level":3,"title":"基础概念","slug":"基础概念","link":"#基础概念","children":[]},{"level":3,"title":"会话技术的发展","slug":"会话技术的发展","link":"#会话技术的发展","children":[]},{"level":3,"title":"分布式会话方案","slug":"分布式会话方案","link":"#分布式会话方案","children":[]},{"level":3,"title":"Token","slug":"token","link":"#token","children":[]}]},{"level":2,"title":"3.分布式事务解决方案","slug":"_3-分布式事务解决方案","link":"#_3-分布式事务解决方案","children":[{"level":3,"title":"什么是分布式事务","slug":"什么是分布式事务","link":"#什么是分布式事务","children":[]},{"level":3,"title":"为什么会有分布式事务","slug":"为什么会有分布式事务","link":"#为什么会有分布式事务","children":[]},{"level":3,"title":"解决方案","slug":"解决方案","link":"#解决方案","children":[]}]}],"git":{"createdTime":1728898204000,"updatedTime":1729096406000,"contributors":[{"name":"George","email":"leiping@yunxianginvest.com","commits":1},{"name":"leiping","email":"leiping@91cyt.com","commits":1}]},"readingTime":{"minutes":15.57,"words":4672},"filePathRelative":"interview/distributed/README.md","localizedDate":"October 14, 2024","excerpt":"\\n<h2>1.分布式缓存及方案实现</h2>\\n<div class=\\"hint-container tip\\">\\n<p class=\\"hint-container-title\\">提示</p>\\n<p>像MySql等传统的关系型数据库已经不能适用于所有的业务场景，比如电商系统的秒杀场景，APP首页的访问流量高峰场景，很容易造成关系型数据库的瘫痪，随着缓存技术的出现很好的解决了这个问题。</p>\\n</div>\\n<h3>缓存的概念（什么是缓存）</h3>\\n<p>缓存就是把访问量较高的热点数据从传统的关系型数据库中加载到内存中，当用户再次访问热点数据时是从内存中加载，减少了对数据库的访问量，解决了高并发场景下容易造成数据库宕机的问题。</p>"}');export{v as comp,f as data};
