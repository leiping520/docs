import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as s,o as e,c as r,a as l,b as p,d as t,e as i}from"./app-dp-5049H.js";const a={},c=l("h1",{id:"一、计算机网络",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#一、计算机网络"},[l("span",null,"一、计算机网络")])],-1),g=l("p",null,[l("strong",null,"基础部分")],-1),h=i('<li><p>TCP报头格式</p><figure><img src="http://s1.51cto.com/images/20171216/1513399302449506.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>端口号用来标识不同的应用程序。</p><ul><li><p><strong>源端口</strong>：标识来源应用程序的</p></li><li><p><strong>目标端口</strong>：标识接收的计算机的应用程序</p></li><li><p><strong>保留</strong>：为将来定义新的用途保留，现在一般置0。</p></li><li><p>：是本报文段发送的数据组的第一个字节的序号 。每个字节一个序号。比如一个报文段是300.数据大小是100字节。那么下一个报文的序号就是400.所以序号确保了TCP传输的有序性</p></li><li><p><strong>ack确认号</strong>：指明下一个期待收到的字节序号，表明该序号之前的所有数据已经正确无误的收到。确认号只有当ACK标志为1时才有效</p></li><li><p><strong>数据偏移／首部长度</strong>：4bits。由于首部可能含有可选项内容，因此TCP报头的长度是不确定的，报头不包含任何任选字段则长度为20字节，4位首部长度字段所能表示的最大值为1111，转化为10进制为15，15*32/8 = 60，故报头最大长度为60字节。首部长度也叫数据偏移，是因为首部长度实际上指示了数据区在报文段中的起始偏移值。</p></li><li><p><strong>保留</strong>：为将来定义新的用途保留，现在一般置0。</p></li><li><p><strong>控制位</strong>：URG  ACK  PSH  RST  SYN  FIN，共6个，每一个标志位表示一个控制功能。</p><ul><li><p>ACK 确认序号</p></li><li><p>SYN同步序号。握手的时候用</p></li><li><p>FIN 关闭连接</p></li></ul></li><li><p><strong>窗口</strong>：滑动窗口大小，用来告知发送端接受端的缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。窗口大小时一个16bit字段，因而窗口大小最大为65535。</p></li><li><p><strong>校验和</strong>：奇偶校验，此校验和是对整个的 TCP 报文段，包括 TCP 头部和 TCP 数据，以 16 位字进行计算所得。由发送端计算和存储，并由接收端进行验证。</p></li><li><p><strong>紧急指针</strong>：只有当 URG 标志置 1 时紧急指针才有效。紧急指针是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。 TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。</p></li><li><p><strong>选项和填充</strong>：最常见的可选字段是最长报文大小，又称为MSS（Maximum Segment Size），每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志为1的那个段）中指明这个选项</p></li><li><p><strong>数据部分</strong>： TCP 报文段中的数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有 TCP 首部</p></li></ul><p>TCP报头中的源端口号和目的端口号同IP数据报中的源IP与目的IP唯一确定一条TCP连接。</p></li><li><p>UDP报头格式</p><figure><img src="https://github.com/xianyunyh/tcp-ip-protocal/raw/master/udp-1.png" alt="udp-1" tabindex="0" loading="lazy"><figcaption>udp-1</figcaption></figure><ul><li>1、源端口号，16bit</li><li>2、目的端口号：数据接收者的端口号，16bit</li><li>3、UDP长度：UDP长度字段指的是UDP首部和UDP数据的字节长度。该字段的最小值为8字节</li><li>4、UPD校验和：UDP检验和覆盖UDP首部和UDP数据</li><li>5、首部长度：首部中32bit字的数目，可表示15*32bit=60字节的首部。一般首部长度为20字节。</li><li>6、数据</li></ul></li><li><p>TCP/UDP区别（不仅是宏观上的，最好能根据各自的机制讲解清楚）</p><p>TCP存在三次握手。能进行流量控制，保证数据的完整。</p><p>UDP不存在握手。会导致丢包。传输比较快。</p></li><li><p>HTTP状态码（最好结合使用场景，比如在缓存命中时使用哪个）</p><p>2xx 标识正常</p><p>3xx 标识重定向 比如301 永久重定向 304 标识使用缓存</p><p>4xx 标识资源未找到 404 文件没找到 403 禁止访问</p><p>5xx 服务器内部错误</p></li><li><p>HTTP协议（一些报头字段的作用，如cace-control、keep-alive）</p></li><li><p>OSI协议、TCP/IP协议以及每层对应的协议。</p></li><li><p>SESSION机制、cookie机制</p></li>',7),d=l("p",null,"TCP三次握手、四次挥手（这个问题真的要回答吐了，不过真的是面试官最喜欢问的，建议每天手撸一遍，而且不只是每次请求的过程，各种FIN_WAIT、TIME_WAIT状态也要掌握）。",-1),u={href:"https://github.com/xianyunyh/tcp-ip-protocal",target:"_blank",rel:"noopener noreferrer"},_=i("<p><strong>三次握手</strong></p><ul><li>客户端将标志位置SYN置1，发送序号为K的数据。客户端进入SYN_SEND状态</li><li>服务端收到数据包后，先确认这个数据[ack=K+1],将自己的标志位SYN置1，发送序号为M的数据。服务端进入SYN_RECV</li><li>客户端收到后。将自己标志位置SYN置1.确认序号为M的数据。[ack=M+1]. ESTABLISHED</li></ul><p><strong>四次挥手</strong></p><ul><li>客户端发送将自己的标识FIN置1.发送序号为M的数据包 客户端进入FIN_WAIT_1</li><li>服务器收到M，先确认ack=M+1。发送ack</li><li>服务器再发送FIN,序号为N的数据包 进入LAST_ACK</li><li>客户端收到后，进入TIME_WAIT,再发送ACK=1.ack=N+1的数据包 服务端进入 CLOSED</li></ul>",4),P=l("li",null,[l("p",null,"打开网页到页面显示之间的过（涵盖了各个方面，DNS解析过程，Nginx请求转发、连接建立和保持过程、浏览器内容渲染过程，考虑的越详细越好）。")],-1),b=l("li",null,[l("p",null,"http和https区别，https在请求时额外的过程，https是如何保证数据安全的")],-1),T=l("li",null,[l("p",null,"IP地址子网划分")],-1),m=l("li",null,[l("p",null,"POST和GET区别")],-1),S=l("li",null,[l("p",null,"DNS解析过程")],-1),C=l("p",null,[l("strong",null,"深入部分")],-1),N=l("ol",{start:"13"},[l("li",null,"TCP如何保证数据的可靠传输的（这个问题可以引申出很多子问题，拥塞控制慢开始、拥塞避免、快重传、滑动窗口协议、停止等待协议、超时重传机制，最好都能掌握）"),l("li",null,"地址解析协议ARP"),l("li",null,"交换机和路由器的区别")],-1),f=l("h1",{id:"二、数据库",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#二、数据库"},[l("span",null,"二、数据库")])],-1),x=l("p",null,[l("strong",null,"基础部分")],-1),I=i("<li><p>事务四大特性（ACID）</p><p>原子性、一致性、隔离性、持久性</p></li><li><p>数据库隔离级别，每个级别会引发什么问题，mysql默认是哪个级</p><p>未提交读 会产生脏读</p><p>提交读：</p><p>重复读：</p><p>序列化</p><p>默认是重复读。</p></li><li><p>MYSQL的两种存储引擎区别（事务、锁级别等等），各自的适用场景</p></li><li><p>数据库的优化（从sql语句优化和索引两个部分回答）</p></li><li><p>索引有B+索引和hash索引，各自的区别</p></li><li><p>B+索引数据结构，和B树的区别</p></li><li><p>索引的分类（主键索引、唯一索引），最左前缀原则，哪些情况索引会失效</p></li>",7),D=l("p",null,"聚集索引和非聚集索引区别。",-1),U={href:"https://blog.csdn.net/zc474235918/article/details/50580639",target:"_blank",rel:"noopener noreferrer"},k=l("p",null,"有哪些锁（乐观锁悲观锁），select时怎么加排它锁",-1),A=l("p",null,"select * from for update; 排它锁",-1),E=l("p",null,"select * from user lock in share mode 共享锁",-1),M={href:"http://www.cnblogs.com/boblogsbo/p/5602122.html",target:"_blank",rel:"noopener noreferrer"},y=i("<li><p>关系型数据库和非关系型数据库区别</p></li><li><p>了解nosql</p></li><li><p>数据库三范式，根据某个场景设计数据表（可以通过手绘ER图）</p></li><li><p>数据库的主从复制</p></li><li><p>使用explain优化sql和索引</p></li><li><p>long_query怎么解决</p></li><li><p>内连接、外连接、交叉连接、笛卡儿积等</p></li>",7),v=i('<p><strong>深入</strong></p><ol><li>MVCC机制</li><li>根据具体场景，说明版本控制机制</li><li>死锁怎么解决</li><li>varchar和char的使用场景。</li><li>mysql并发情况下怎么解决（通过事务、隔离级别、锁）</li></ol><p><strong>Redis</strong></p><ol><li>redis数据结构有哪些</li><li>redis队列应用场景</li><li>redis和Memcached（支持数据持久化）</li><li>分布式使用场景（储存session等）</li><li>发布/订阅使用场景</li></ol><h1 id="三、操作系统" tabindex="-1"><a class="header-anchor" href="#三、操作系统"><span>三、操作系统</span></a></h1><ol><li>内存的页面置换算法</li><li>进程调度算法</li><li>进程间通信方式</li><li>进程线程区别</li><li>进程之间的通信</li><li>父子进程、孤儿进程</li><li>fork进程时的操作， ​</li></ol><h1 id="四、算法" tabindex="-1"><a class="header-anchor" href="#四、算法"><span>四、算法</span></a></h1><p><strong>基础</strong></p><ol><li><p>二叉树相关（层次遍历、求深度、求两个节点距离、翻转二叉树、前中后序遍历）</p></li><li><p>链表相关（插入节点、链表逆置、使用链表进行大数字的加减，双向链表实现队列、寻找链表中的环）</p></li><li><p>堆（大量数据中寻找最大N个数字几乎每次都会问，还有堆在插入时进行的调整）</p></li><li><p>排序（八大排序，各自的时间复杂度、排序算法的稳定性。快排几乎每次都问）</p></li><li><p>二分查找（一般会深入，如寻找数组总和为K的两个数字）</p></li><li><p>两个栈实现队列。</p></li><li><p>图（深度广度优先遍历、单源最短路径、最小生成树）</p></li><li><p>动态规划问题。</p><p><strong>深入</strong></p></li><li><p>红黑树性质</p></li><li><p>分治法和动态规划的区别</p></li><li><p>计算时间复杂度</p></li><li><p>二叉树和哈希表查找的时间复杂度</p></li></ol><p><strong>具体题目</strong></p><ol><li><p>一个文本文件中每一行中有一个URL，最多一万行，统计每一个URL的次数，输出到另外一个文件中，每一行前面是URL，后面是个数。</p></li><li><p>单链表的逆序</p><p>利用栈 遍历链表。每次压栈。然后每次再出栈。</p></li><li><p>一个函数实现给定字符串，去除前面和后面的空格，比如“ ab cd ”，最后得到的结果是”ab cd”，不能改变字符串的地址。</p></li><li><p>对比cookie和session,有一个值错误则不正确</p></li><li><p>查找10的阶乘后面有几个0</p></li><li><p>字符串匹配</p></li><li><p>字符串移位，给出字符串abc##dfg##gh，实现将所有#移至字符串串头。输出####abcdfggh（个人认为可以用后向移位，减少移位次数）</p></li><li><p>给出一颗二叉树，两个叶节点，找到这两个叶节点互连通的一条最短路径。</p></li><li><p>两个日期计算天数差</p></li><li><p>100个有序数组合并</p></li><li><p>矩阵的最大子矩阵和</p></li><li><p>给定一棵多叉树，每个节点有一个编号，现在要对节点排序，要求对于每个节点，它的父节点排在它后面,如果一棵树有N个节点，那么肯定有N-1条边。输入的数据形式为：Map.Entry</p></li></ol><h1 id="linux" tabindex="-1"><a class="header-anchor" href="#linux"><span>LINUX</span></a></h1><ol><li>硬链接和软连接区别</li><li>kill用法，某个进程杀不掉的原因（进入内核态，忽略kill信号）</li><li>linux用过的命令</li><li>系统管理命令（如查看内存使用、网络情况）</li><li>管道的使用 |</li><li>grep的使用，一定要掌握，每次都会问在文件中查找</li><li>shell脚本</li><li>find命令</li><li>awk使用</li></ol><h1 id="语言部分-php" tabindex="-1"><a class="header-anchor" href="#语言部分-php"><span>语言部分（PHP）</span></a></h1><ol><li>数组操作函数</li><li>字符串操作函数（数组和字符串的函数是最常问的，非常多，一定不要记混了）</li><li>指针和引用区别</li><li>堆和栈的区别</li><li>== ===区别</li><li>PHP的垃圾回收机制</li><li>zval结构</li><li>防sql注入</li><li>跨域问题</li><li>长链接和长轮询</li></ol><p><strong>面向对象、设计模式</strong></p><ol><li>接口和抽象类区别</li><li>单继承</li><li>construct的调用顺序（子类父类之间）</li><li>设计模式（工厂模式、策略模式、单例模式、装饰模式比较常见）</li><li>OOP特性，通过哪些机制实现的</li><li>重写和重载区别</li><li>静态类静态方法</li><li>根据某个需求设计一个类（主要考虑类之间的继承关系和属性的权限设置）</li></ol><h1 id="项目" tabindex="-1"><a class="header-anchor" href="#项目"><span>项目</span></a></h1><ol><li>项目中遇到的困难（提前想好，并且把实现或者优化方法说清楚）</li><li>系统的量级、pv、uv等</li><li>应对高并发的解决办法（分布式）</li><li>在项目中主要负责了哪些工作。</li><li>nginx的负载均衡</li><li>分布式缓存的一致性，服务器如何扩容（哈希环）</li><li>项目中用到了哪些技术</li><li>服务器性能如何测试</li><li>项目中印象深刻的东西</li><li>项目中遇到过哪些坑，怎么解决的</li><li>项目中为什么用redis以及怎么实现相关功能</li><li>用过的开源框架（路由问题），框架的原理</li><li>消息队列的应用场景（想一个）</li><li>有没有用到非关系型数据库</li><li>网站负载变大时怎么办</li><li>SOA?</li><li>WebService?</li><li>《大型网站技术架构：核心原理与案例分析》</li><li>redis的消息队列 redis的数据类型</li><li>OAuth认证过程</li><li>单点登陆系统 分布式缓存的使用场景</li><li>一个Controller调用两个Service，这两Service又都分别调用两个Dao，问其中用到了几个数据库连接池的连接？</li><li>图片是怎么存储的</li><li>分布式一致性协议、分布式锁（应用场景）</li><li>项目中的网络编程</li><li>划一下项目的架构</li><li>MVC的路由机制怎么实现的（路由很重要）</li><li>为什么要用hadoop</li><li>自己写的接口如何防止被别人恶意调用？印象笔记</li><li>如何实现数据容灾，</li><li>怎样实现负载均衡</li><li>如何解决单节点负载过</li><li>Redis和memcache区别</li><li>redis的持久化</li></ol>',19);function Y(R,K){const n=s("ExternalLinkIcon");return e(),r("div",null,[c,g,l("ol",null,[h,l("li",null,[d,l("p",null,[l("a",u,[p("TCP详解"),t(n)])]),_]),P,b,T,m,S]),C,N,f,x,l("ol",null,[I,l("li",null,[D,l("p",null,[l("a",U,[p("聚集索引和非聚集索引区别"),t(n)])])]),l("li",null,[k,A,E,l("p",null,[l("a",M,[p("mysql共享锁与排他锁"),t(n)])])]),y]),v])}const L=o(a,[["render",Y],["__file","笔试题2.html.vue"]]),w=JSON.parse('{"path":"/interview/interview_qa/%E7%AC%94%E8%AF%95%E9%A2%982.html","title":"一、计算机网络","lang":"en-US","frontmatter":{"icon":"home","toc":true,"sidebar":false,"breadcrumb":false},"headers":[],"git":{"createdTime":1729172701000,"updatedTime":1729172701000,"contributors":[{"name":"leiping","email":"leiping@91cyt.com","commits":1}]},"readingTime":{"minutes":11.39,"words":3416},"filePathRelative":"interview/interview_qa/笔试题2.md","localizedDate":"October 17, 2024","excerpt":"\\n<p><strong>基础部分</strong></p>\\n<ol>\\n<li>\\n<p>TCP报头格式</p>\\n<figure><img src=\\"http://s1.51cto.com/images/20171216/1513399302449506.png\\" alt=\\"img\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>img</figcaption></figure>\\n<p>端口号用来标识不同的应用程序。</p>\\n<ul>\\n<li>\\n<p><strong>源端口</strong>：标识来源应用程序的</p>\\n</li>\\n<li>\\n<p><strong>目标端口</strong>：标识接收的计算机的应用程序</p>\\n</li>\\n<li>\\n<p><strong>保留</strong>：为将来定义新的用途保留，现在一般置0。</p>\\n</li>\\n<li>\\n<p>：是本报文段发送的数据组的第一个字节的序号 。每个字节一个序号。比如一个报文段是300.数据大小是100字节。那么下一个报文的序号就是400.所以序号确保了TCP传输的有序性</p>\\n</li>\\n<li>\\n<p><strong>ack确认号</strong>：指明下一个期待收到的字节序号，表明该序号之前的所有数据已经正确无误的收到。确认号只有当ACK标志为1时才有效</p>\\n</li>\\n<li>\\n<p><strong>数据偏移／首部长度</strong>：4bits。由于首部可能含有可选项内容，因此TCP报头的长度是不确定的，报头不包含任何任选字段则长度为20字节，4位首部长度字段所能表示的最大值为1111，转化为10进制为15，15*32/8 = 60，故报头最大长度为60字节。首部长度也叫数据偏移，是因为首部长度实际上指示了数据区在报文段中的起始偏移值。</p>\\n</li>\\n<li>\\n<p><strong>保留</strong>：为将来定义新的用途保留，现在一般置0。</p>\\n</li>\\n<li>\\n<p><strong>控制位</strong>：URG &nbsp;ACK &nbsp;PSH &nbsp;RST &nbsp;SYN &nbsp;FIN，共6个，每一个标志位表示一个控制功能。</p>\\n<ul>\\n<li>\\n<p>ACK 确认序号</p>\\n</li>\\n<li>\\n<p>SYN同步序号。握手的时候用</p>\\n</li>\\n<li>\\n<p>FIN 关闭连接</p>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>窗口</strong>：滑动窗口大小，用来告知发送端接受端的缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。窗口大小时一个16bit字段，因而窗口大小最大为65535。</p>\\n</li>\\n<li>\\n<p><strong>校验和</strong>：奇偶校验，此校验和是对整个的&nbsp;TCP&nbsp;报文段，包括&nbsp;TCP&nbsp;头部和&nbsp;TCP&nbsp;数据，以&nbsp;16&nbsp;位字进行计算所得。由发送端计算和存储，并由接收端进行验证。</p>\\n</li>\\n<li>\\n<p><strong>紧急指针</strong>：只有当&nbsp;URG&nbsp;标志置&nbsp;1&nbsp;时紧急指针才有效。紧急指针是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。&nbsp;TCP&nbsp;的紧急方式是发送端向另一端发送紧急数据的一种方式。</p>\\n</li>\\n<li>\\n<p><strong>选项和填充</strong>：最常见的可选字段是最长报文大小，又称为MSS（Maximum Segment Size），每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志为1的那个段）中指明这个选项</p>\\n</li>\\n<li>\\n<p><strong>数据部分</strong>：&nbsp;TCP&nbsp;报文段中的数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有&nbsp;TCP&nbsp;首部</p>\\n</li>\\n</ul>\\n<p>TCP报头中的源端口号和目的端口号同IP数据报中的源IP与目的IP唯一确定一条TCP连接。</p>\\n</li>\\n<li>\\n<p>UDP报头格式</p>\\n<figure><img src=\\"https://github.com/xianyunyh/tcp-ip-protocal/raw/master/udp-1.png\\" alt=\\"udp-1\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>udp-1</figcaption></figure>\\n<ul>\\n<li>1、源端口号，16bit</li>\\n<li>2、目的端口号：数据接收者的端口号，16bit</li>\\n<li>3、UDP长度：UDP长度字段指的是UDP首部和UDP数据的字节长度。该字段的最小值为8字节</li>\\n<li>4、UPD校验和：UDP检验和覆盖UDP首部和UDP数据</li>\\n<li>5、首部长度：首部中32bit字的数目，可表示15*32bit=60字节的首部。一般首部长度为20字节。</li>\\n<li>6、数据</li>\\n</ul>\\n</li>\\n<li>\\n<p>TCP/UDP区别（不仅是宏观上的，最好能根据各自的机制讲解清楚）</p>\\n<p>TCP存在三次握手。能进行流量控制，保证数据的完整。</p>\\n<p>UDP不存在握手。会导致丢包。传输比较快。</p>\\n</li>\\n<li>\\n<p>HTTP状态码（最好结合使用场景，比如在缓存命中时使用哪个）</p>\\n<p>2xx 标识正常</p>\\n<p>3xx 标识重定向 比如301 永久重定向 304 标识使用缓存</p>\\n<p>4xx 标识资源未找到 404 文件没找到 403 禁止访问</p>\\n<p>5xx 服务器内部错误</p>\\n</li>\\n<li>\\n<p>HTTP协议（一些报头字段的作用，如cace-control、keep-alive）</p>\\n</li>\\n<li>\\n<p>OSI协议、TCP/IP协议以及每层对应的协议。</p>\\n</li>\\n<li>\\n<p>SESSION机制、cookie机制</p>\\n</li>\\n<li>\\n<p>TCP三次握手、四次挥手（这个问题真的要回答吐了，不过真的是面试官最喜欢问的，建议每天手撸一遍，而且不只是每次请求的过程，各种FIN_WAIT、TIME_WAIT状态也要掌握）。</p>\\n<p><a href=\\"https://github.com/xianyunyh/tcp-ip-protocal\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">TCP详解</a></p>\\n<p><strong>三次握手</strong></p>\\n<ul>\\n<li>客户端将标志位置SYN置1，发送序号为K的数据。客户端进入SYN_SEND状态</li>\\n<li>服务端收到数据包后，先确认这个数据[ack=K+1],将自己的标志位SYN置1，发送序号为M的数据。服务端进入SYN_RECV</li>\\n<li>客户端收到后。将自己标志位置SYN置1.确认序号为M的数据。[ack=M+1]. ESTABLISHED</li>\\n</ul>\\n<p><strong>四次挥手</strong></p>\\n<ul>\\n<li>客户端发送将自己的标识FIN置1.发送序号为M的数据包 客户端进入FIN_WAIT_1</li>\\n<li>服务器收到M，先确认ack=M+1。发送ack</li>\\n<li>服务器再发送FIN,序号为N的数据包 进入LAST_ACK</li>\\n<li>客户端收到后，进入TIME_WAIT,再发送ACK=1.ack=N+1的数据包 服务端进入 CLOSED</li>\\n</ul>\\n</li>\\n<li>\\n<p>打开网页到页面显示之间的过（涵盖了各个方面，DNS解析过程，Nginx请求转发、连接建立和保持过程、浏览器内容渲染过程，考虑的越详细越好）。</p>\\n</li>\\n<li>\\n<p>http和https区别，https在请求时额外的过程，https是如何保证数据安全的</p>\\n</li>\\n<li>\\n<p>IP地址子网划分</p>\\n</li>\\n<li>\\n<p>POST和GET区别</p>\\n</li>\\n<li>\\n<p>DNS解析过程</p>\\n</li>\\n</ol>"}');export{L as comp,w as data};
